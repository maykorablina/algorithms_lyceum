# Целые числа в C++
## Introduction: ввод и вывод

В C++ для работы с консолью чаще всего используют библиотеку <iostream>.

```cpp
#include <iostream>
```

Мы не будем использовать `using namespace std;`, потому что это может вызвать конфликты имен (в стандартной библиотеке очень много функций и классов с распространёнными названиями, например `count`, `max`, `sort`), а также потому что важно привыкать к хорошему стилю программирования :)

В больших проектах очев лучше писать  `std::cout`, `std::string`, `std::vector`, чтобы код был читаемым, понятным и безопасным.

2. **Вывод: cout**

Оператор: << («потоковый сдвиг»).

Все, что записываем через <<, выводится на экран слева направо.

Примеры:

```cpp
std::cout << "Hello, world!\n";
std::cout << 42 << " " << 3.14 << "\n";
```

Про перенос строки:

- `\n` — это просто символ новой строки. Он попадает в буфер вывода, и текст отобразится, когда буфер очистится (обычно при завершении программы или при заполнении буфера).
- `std::endl` — делает то же самое, но дополнительно очищает буфер (flush).

Для нас особо разницы нет - и то, и то делает перенос строки, но:

- `\n` быстрее → очень круто для алгоритмов
- `std::endl` медленнее

3. **Ввод: cin**

Оператор: >>.

Считывает данные через пробел/перевод строки.

Пример:

```cpp
int x; double y;
std::cin >> x >> y;  // ввод: 5 3.14
std::cout << x << " " << y << "\n"; // вывод: 5 3.14

// std::cin игнорирует  пробелы и \n
```

## Целые числа в С++

### В C++ есть два вида целых чисел

**`signed`** — со знаком

Это обычные целые числа: положительные, отрицательные и 0.

Диапазон зависит от размера типа. Например:

`int` (обычно 32 бита): от −2 147 483 648 до 2 147 483 647.

**`unsigned`** — без знака

Тут нет отрицательных чисел. Поэтому диапазон в 2 раза шире, чем у signed.

`unsigned int` (32 бита): от 0 до 4 294 967 295.

**Почему это так (может быть тяжело для понимания)?&#32;**Компьютер хранит числа как набор битов. В `signed`-версии числа первый бит всегда отдается под знак (0 - положительное число, 1 - отрицательное число)

Например:

`00000101` -> первый бит 0 -> число положительное (в нашем случае это 5)

`11111011` -> первый бит 1 -> число отрицательное -> \~11111011 + 1 = 5 -> это число -5

Таким образом, если у нас n-битовое представление числа, то в `signed`-версии у нас будет:

-  $2^{n -1}$ отрицательных чисел (-1 в степени говорит, что один бит зарезервирован под знак)
- и $2^{n -1} - 1$ неотрицательных чисел (то есть >= 0, ноль тоже существует, просто отдельно)

Когда же мы используем `unsigned`-версию, то мы не резервируем первый бит под знак. Соответственно, в нашем распоряжении будет $2^{n}$ неотрицательных чисел (то есть >= 0)

### Все целые типы в C++

1. **short int (short)**  

  - **Обычно:** 2 байта (16 бит)
  - **Диапазон (signed)**: –32 768 … 32 767.  
  - **unsigned:** 0 … 65 535.  

2. **int**  

  - **Обычно:** 4 байта (32 бита).  
  - **Диапазон:** (signed): –2 147 483 648 … 2 147 483 647.  
  - **unsigned:** 0 … 4 294 967 295.  

3. **long int (long)**  

  - **Обычно:**  
    - 4 байта на Windows (даже в 64-битной системе!).  
    - 8 байт на Linux/macOS (LP64-системы).  
  - **Диапазон:**  
    - 32 бита → как у int.  
    - 64 бита → –9 223 372 036 854 775 808 … 9 223 372 036 854 775 807.  
    - **`unsigned`**: 0 … 4 294 967 295

4. **long long int (long long)**  

  - **Обычно:** 8 байт (64 бита) на всех современных платформах.  
  - **Диапазон:** (signed, 64 бит): –9 223 372 036 854 775 808 … 9 223 372 036 854 775 807.  
  - **unsigned:** 0 … 18 446 744 073 709 551 615.  **&#32;**

### Основные операции с целыми числами

1. **Целочисленное деление**

В C++ при делении целых чисел дробная часть отбрасывается.

```cpp
std::cout << 7 / 2 << "\n";   // 3
std::cout << -7 / 2 << "\n";  // -3
```

Округление всегда в меньшую сторону!

2. **Остаток % (modulo)**

Остаток берётся с тем же знаком, что и у делимого.

```cpp
std::cout << 7 % 2 << "\n";   // 1
std::cout << -7 % 2 << "\n";  // -1
std::cout << 7 % -2 << "\n";  // 1
std::cout << -7 % -2 << "\n"; // -1
```

То есть правило:

$a = \left( \frac{a}{b} \right) \times b + \left( a \bmod b \right)$

Например,`&#32;-7 / 2 = -3,` значит:  
`-7 = (-3)*2 + остаток`, и остаток = -1.

## **Побитовые операции**

- `&` — побитовое **И** (AND)  
- `|` — побитовое **ИЛИ** (OR)  
- `^` — побитовое **XOR** (исключающее ИЛИ)  
- `~` — побитовое **НЕ** (NOT), инверсия всех битов  
- `<<` — сдвиг влево (умножение на `2^k` с возможным обрезанием)  
- `>>` — сдвиг вправо (деление на `2^k` без остатка)  

1. **Побитовое И (&)**

Ставит 1 только там, где в обоих числах 1.

```cpp
int a = 6;   // 0110
int b = 5;   // 0101
std::cout << (a & b) << "\n"; // 0100 = 4
```

2. **Побитовое ИЛИ (|)**

Ставит 1, если хотя бы в одном числе 1.

```cpp
int a = 6;   // 0110
int b = 5;   // 0101
std::cout << (a | b) << "\n"; // 0111 = 7
```

3. **Побитовое исключающее ИЛИ (^)**

Ставит 1, если биты разные.

```cpp
int a = 6;   // 0110
int b = 5;   // 0101
std::cout << (a ^ b) << "\n"; // 0011 = 3
```

4. **Побитовое НЕ (\~)**

Инвертирует каждый бит (0 → 1, 1 → 0).

```cpp
int a = 6;   // 0000...0110
std::cout << (~a) << "\n"; //1111...1001 = -7
```

5. **`x << k`&#32;— сдвиг влево**

математически, 

$x \ll k = \left( x \times 2^k \right) \bmod 2^n$,

$n $ - количество бит в типе (sizeof(x) \* 8), определяется типом int-а

грубо говоря, левый сдвиг — это **умножение на степень двойки**.

Пример:  $5≪1$

- $5$ - обычный `int`, т.е. $n = 4 * 8 = 32$
- $5 \ll 1 = (5 \times 2^1) \bmod 2^{32} = 10 \bmod 2^{32}$
- Так как $10 < 2^{32}$, остаток равен самому числу

Ответ: $5≪1 = 10$ 

```cpp
int x = 5;   
std::cout << (x << 1) << "\n"; // 10
```

**Пример побитово:**

5 = `00000101`  

5 ≪ 1 - Каждый бит «переезжает» на одну позицию левее

`00000101&#32;` → `00001010` → 10


6.  **`x >> n`&#32;— сдвиг вправо**

математически,

$x \gg k = \left\lfloor \frac{x}{2^k} \right\rfloor$ 

$\left\lfloor\right\rfloor$ - округление вниз

по сути, это **целочисленное деление на степень двойки**.

Пример: $20\gg1 $

- $20\gg1 = 20 / 2^{1} = 10$

```cpp
int x = 20;   
std::cout << (20 >> 1) << "\n";
```

**Пример побитово:**

20 = `00010100`

20 << 1 -Каждый бит «съезжает» на одну позицию вправо, слева добавляется `0`

`00010100`  → `00001010`  → 10

### Зачем нам это надо?

Компьютер **хранит числа как набор битов**. Битовые операции позволяют работать **с каждым битом числа отдельно**. Когда мы делаем битовые операции, они просто меняют нули и единицы в памяти. Это самое «естественное» действие для процессора, поэтому оно выполняется моментально.

Например:

- Для умножения (`a * b`) процессор разбивает операцию умножения на части (в основном разбивает на множество сложений, вычитаний и делений).
- Деление (`a / b`) - еще сложнее — обычно это последовательность вычитаний и сдвигов.

Например, замена умножения и деления на битовые операции работает быстрее (на уровне компьютера, мы этой разницы в скорости не заметим), и выглядит более прикольно:

```cpp
x << 1   // быстрее, чем x * 2
x >> 3   // быстрее, чем x / 8
```

**Еще интересные примеры**:

1. **Проверка четности&#32;**(кстати, тут битовая операция по скорости зарешает)

```cpp
// Noob
x % 2 == 0
// Pro
(x & 1) == 0
```

2. **Обмен значений двух переменных&#32;**(здесь оптимизация по памяти - не создаем новую переменную)

```cpp
// Noob
int temp = a;
a = b;
b = temp;

// Pro
a = a ^ b;  // a хранит XOR двух чисел
b = a ^ b;  // b = (a^b)^b = a
a = a ^ b;  // a = (a^b)^a = b
```

3. **Операция "просто повыпендриваться"**

```cpp
// Noob
-x - 1

// Pro
~x
```

## Переполнение

**Переполнение** — ситуация, когда результат вычисления выходит за пределы диапазона типа данных


Компьютер хранит числа в фиксированном количестве бит, и если число не помещается, старшие биты «теряются» → результат искажается

1. **Переполнение у&#32;`signed`-версии** (`short`, `int`, `long`, `long long`)

Например, `int` (обычно 32 бита): −2 147 483 648 … 2 147 483 647.

Если результат выходит за эти границы → **неопределенное поведение (UB)**.

На практике на большинстве ПК «перескакивает» через край, но зависит от ПК.

```cpp
int x = 2147483647; // максимум int
std::cout << x + 1 << "\n"; // UB, чаще всего -2147483648
```

2. **Переполнение у&#32;`unsigned`-версии** (`unsigned short`, `unsigned int` ...)

У unsigned переполнение чётко определено стандартом.

Результат вычисляется по модулю $2^{n}$ (x % $2^{n}$)

То есть счeтчик «зацикливается»

```cpp
unsigned int y = 4294967295; // максимум 2^32-1
std::cout << y + 1 << "\n"; // 0
std::cout << y + 2 << "\n"; // 1
```

**Пример побитово:**

`unsigned short (16 бит)`

Диапазон: 0 … 65 535

65535 + 1 = `1111 1111 1111 1111` + `0000 0000 0000 0001` = `1&#32;0000 0000 0000 0000` (отбрасываем 17 бит) =`&#32;0000 0000 0000 0000&#32;` = 0

**Почему это важно**

- Ошибки и неверные результаты в программах.
- В контестах - WA из-за выхода суммы или произведения за диапазон `int`.
- В реальных проектах — много много багов

**Как бороться с переполнением**

1. Выбирать правильный тип
  - Для больших чисел → `long long` (64 бита).
2. Если в задаче известен размер числа, лучше использовать типы из `<cstdint>`

`<cstdint>` — это библиотека, в которой описаны целые типы с фиксированным размером.

Конечно, от переполнения это полностью не спасет, оно будет работать по правилам обычных целых чисел, однако, зная точный размер числа, мы имеем больше контроля над операциями и можем легко использовать битовые операции.

| Тип        | Размер | Диапазон |
|-------------|---------|-----------|
| `int8_t`    | 8 бит   | −128 … 127 |
| `uint8_t`   | 8 бит   | 0 … 255 |
| `int16_t`   | 16 бит  | −32 768 … 32 767 |
| `uint16_t`  | 16 бит  | 0 … 65 535 |
| `int32_t`   | 32 бит  | −2 147 483 648 … 2 147 483 647 |
| `uint32_t`  | 32 бит  | 0 … 4 294 967 295 |
| `int64_t`   | 64 бит  | −9 223 372 036 854 775 808 … 9 223 372 036 854 775 807 |
| `uint64_t`  | 64 бит  | 0 … 18 446 744 073 709 551 615 |

