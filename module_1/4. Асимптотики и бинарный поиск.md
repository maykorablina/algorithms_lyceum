## Формализация понятия алгоритма

Алгоритм — это конечная последовательность действий, направленных на решение задачи.

### Свойства алгоритма:

- **Дискретность** — делится на отдельные шаги.
- **Определенность** — каждый шаг понятен и однозначен.
- **Результативность** — приводит к результату за конечное число шагов.
- **Массовость** — применим к целому классу задач

## Сложность алгоритма

Когда мы придумываем или выбираем алгоритм, важно понимать не только то, что он работает правильно, но и то, насколько он эффективен. Эффективность измеряется двумя основными параметрами:

- **Время работы** — сколько шагов делает алгоритм, чтобы получить ответ.
- **Память** — сколько дополнительной информации нужно хранить во время работы.

На маленьких данных разница может быть незаметной. Например:

- сложить числа в списке из 10 элементов можно любым способом, это займет доли секунды;
- но если элементов будет 10 миллионов, один алгоритм может справиться за секунды, а другой — за часы.

Чтобы уметь сравнивать разные алгоритмы, нужна удобная система для сравнения

### O-большое

Вместо того чтобы считать точное количество шагов (оно зависит от деталей программы и компьютера), используют обозначение **O(...)** (big-O, O-большое), которое показывает как растет время работы или расход памяти при увеличении числа данных

Для начала рассмотрим временную сложность, про нее будем говорить чаще всего

**Как оценивается время**

- **O(1)** — константное время
  Алгоритм делает одинаковое число шагов при любом объеме данных.
**&#32;&#32;Пример:** взять первый элемент списка.
- **O(n)** — линейное время
  Нужно пройтись по каждому элементу.
  **Пример:&#32;**найти сумму всех чисел в списке.
- **O(n²)** — квадратичное время
  Каждый элемент сравнивается со всеми остальными.
  **Пример:&#32;**проверить все возможные пары учеников в классе.
- **O(log n)** — логарифмическое время
  На каждом шаге данные сокращаются примерно в два раза.
  **Пример:** бинарный поиск

**Пример:**

Представим стопку из 10 книг и задачу найти нужную:

- если просматривать по порядку, потребуется до 10 шагов → **O(n)**
- если делить стопку пополам и каждый раз отбрасывать ненужную часть, достаточно всего 4 шагов → **O(log n)**

Если книг станет 1000:

- последовательный просмотр займет до 1000 шагов
- бинарный поиск — всего около 10 шагов

**Как оценивается память**

- **O(1)** — постоянная память.  
Алгоритм использует одно и то же количество памяти, независимо от длины списка.  
Пример: поиск минимума с помощью одной переменной.
- **O(n)** — линейная память.  
Чем больше входных данных, тем больше памяти требуется.  
Пример: хранить копию всего списка или массив промежуточных сумм.
- **O(log n)** — логарифмическая память.  
Встречается в рекурсивных алгоритмах, когда задача делится пополам.  
Пример: рекурсивный бинарный поиск. Глубина рекурсии равна числу делений массива пополам, то есть log₂(n).
- **O(n²), O(n³)** и т. д. — память тоже может расти квадратично или кубически, если алгоритм хранит таблицы или матрицы для промежуточных расчетов.  
Пример: динамическое программирование, где строится таблица из n×n элементов.

**Пример:**

Найти сумму элементов списка из n чисел:

- если считать в одной переменной →**&#32;O(1)**
- если сохранять все промежуточные суммы → O**(n)**

Найти число в отсортированном списке (бинарный поиск):

- при циклической реализации → O**(1)**
- при рекурсивной реализации → O**(log n)**

## Смысл нотации O-большое

Нотация O(...) придумана не для того, чтобы посчитать точное количество шагов, а чтобы показать, как в принципе растет время работы алгоритма при увеличении входных данных.

Поэтому в этой записи специально делают несколько упрощений:

- **Не учитывают константы.&#32;&#32;**
  Нас не интересует, делает ли алгоритм 1 шаг на элемент, 3 шага или 100 шагов. Важно, что он делает «фиксированное количество шагов на каждый элемент», то есть растет линейно.

  Пример: O(100) → O(1).

  Пример: O(3n) → O(n).

- **Смотрят только на самый быстрорастущий член.&#32;&#32;**
  Если в формуле есть несколько частей, берут ту, которая быстрее всего растет при больших n.

  Пример: O(n² + n) → O(n²).

  Пример: O(n³ + 5n) → O(n³).

Итоговая запись отражает только «тип роста»:

- O(1) — не зависит от размера данных.
- O(n) — растет линейно.
- O(n²) — растет квадратично.
- O(log n) — растет очень медленно, логарифмически.

**Пример:**

**Алгоритм А:** для списка из 1000 элементов делает 3000 операций → O(3n).

**Алгоритм B:&#32;**для списка из 1000 элементов делает 1000 операций → O(n)

Формально А в три раза медленнее, но оба алгоритма линейные. 
Если список станет в 100 раз больше, то и время работы вырастет в 100 раз у обоих


Поэтому в нотации O-большое они одинаковые: O(n)

![](https://static-file-service.macro.com/file/1b0c52fd-1ed6-4d27-a0ed-cfb596da8e28)

## Операции в нотации сложности

### Сложение ( + )

Если алгоритм состоит из нескольких частей, выполняемых последовательно, то общая сложность — это сумма сложностей этих частей.

Например:

```cpp
for (int i = 0; i < n; i++) {
    // что-то делаем
}                  // O(n)

for (int j = 0; j < m; j++) {
    // что-то делаем
}                  // O(m)
```

**Общая сложность:&#32;**O(n + m)

Но если речь идет об одном и том же n, то при больших данных учитывают только самый «быстрорастущий» член:

O(n + n²) = O(n²)

O(n + log n) = O(n)

### Умножение ( \* )

Умножение появляется, когда один алгоритм выполняется внутри другого (вложенные циклы или повторяющиеся операции).

Пример:

```cpp
for (int i = 0; i < n; i++) {      // O(n)
    for (int j = 0; j < m; j++) {  // O(m)
        // что-то делаем
    }
}
```

Здесь каждая итерация внешнего цикла запускает внутренний цикл.
**Общая сложность:&#32;O(n \* m)**

*Если m = n, то это:&#32;O(n²)*

Примеры «+» и «\*» вместе

```cpp
// Сначала O(n), потом O(n²)
for (int i = 0; i < n; i++) { }         // O(n)
for (int i = 0; i < n; i++) {
    for (int j = 0; j < n; j++) { }     // O(n²)
}
```

Общая сложность: O(n + n²) = O(n²)

```cpp
// Внутри каждого шага внешнего цикла делаем O(n)
for (int i = 0; i < n; i++) {       // O(n)
    for (int j = 0; j < n; j++) {   // O(n)
    }
}
```

Общая сложность: O(n \* n) = O(n²)

---

А теперь нам пора переходить непосредственно к алгоритмам!

Начнем с разбора самого популярного алгоритма - **бинарного поиска**

## Бинарный поиск

Представим задачу: нужно найти число в массиве. 

Есть два способа:

**Линейный поиск**

- Проверяем элементы по одному: первый, второй, третий…
- Простой, но медленный: в худшем случае O(n) шагов.

Для массива из миллиона элементов может понадобиться миллион проверок.

**Бинарный поиск**

**Работает только на отсортированном массиве!!**
**Идея: не проверять все подряд, а каждый раз делить массив пополам.**

- За одно сравнение отбрасываем сразу половину массива.
- Сложность: O(log n). Для миллиона элементов нужно всего около 20 шагов.

Именно поэтому бинарный поиск используется везде, где важна скорость поиска в больших массивах.

## Пошаговый алгоритм бинарного поиска

1. Начинаем с крайних границ массива.  
   Левая граница (left) — это первый элемент.  
   Правая граница (right) — это последний элемент.

```cpp
   int left = 0;
   int right = a.size() - 1;
```

2. Запускаем цикл: пока левая граница не «перепрыгнула» правую.

```cpp
   while (left <= right) {
       ...
   }
```

3. Находим середину массива.  
   Берем число посередине:

```cpp
   int mid = left + (right - left) / 2;
```

4. Сравниваем середину с искомым числом x.

  - Если совпало → мы нашли число!

```cpp
     if (a[mid] == x) return mid;
```

  - Если середина меньше, чем x → значит, искомое число правее.

```cpp
     else if (a[mid] < x) left = mid + 1;
```

  - Иначе число должно быть левее.

```cpp
     else right = mid - 1;
```

5. Если цикл закончился, значит числа нет.

```cpp
   return -1;

```

```cpp
#include <iostream>
#include <vector>

int binary_search(const std::vector<int>& a, int x) {
    int left = 0;
    int right = a.size() - 1;

    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (a[mid] == x) {
            return mid; 
        }
        else if (a[mid] < x) {
            left = mid + 1;
        }
        else {
            right = mid - 1;
        }
    }

    return -1;
}

int main() {
    std::vector<int> a = {1, 3, 4, 7, 9, 12, 18, 21, 25, 30};

    int x;
    std::cin >> x;

    int idx = binary_search(a, x);

    if (idx != -1) {
        std::cout << "Найдено: a[" << idx << "] = " << a[idx] << "\n";
    } else {
        std::cout << "Элемент не найден" << "\n";
    }

    return 0;
}
```

**Реализация алгоритма на С++**

## 
