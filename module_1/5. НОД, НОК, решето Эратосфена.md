## НОД (наибольший общий делитель)

**НОД двух чисел** — это наибольшее число, которое делит оба числа без остатка.

Например:

$НОД(12, 8) = 4$

Потому что:

- делители `12` → `1, 2, 3, 4, 6, 12`
- делители `8` →`1, 2, 4, 8`

-> $НОД = 4$

Для вычисления НОД двух чисел `a` и `b` наиболее эффективным является **алгоритм Евклида**. 

Алгоритм использует тот факт, что

$НОД(a, b) = НОД(b, a\mod b)$

пока `b` не станет равным нулю. В этом случае НОД равен `a`.

### Доказательство

Пусть есть два числа `a` и `b` и пусть

$a = b \times q + r$

где 

- `q` — это целая часть от деления,
- `r` — остаток

Предположим, что какое-то число `d` делит `a` и `b`. 

Это значит:

$a = d \times k_1, \quad b = d \times k_2$

для некоторых целых чисел `k1` и `k2`.

Подставим это в уравнение деления 

$d \times k_1 = (d \times k_2) \times q + r$

Раскроем скобки:

$d \times k_1 = d \times (k_2 \times q) + r$

Перенесем все, что содержит `d`, в одну часть:

$r = d \times (k_1 - k_2 \times q)$

Получаем, что **`r` делится на `d`**

Вывод: если `d` делит `a` и `b`, то `d` делит и остаток `r`.

А значит, **все общие делители&#32;`a`&#32;и&#32;`b`— это те же самые делители, что и&#32;`b`&#32;и&#32;`r`.&#32;**

Поэтому:

${НОД}(a,b) = \text{НОД}(b,r) = НОД(b, a \bmod b)$

**Пример на числах**

Когда мы делим `48` на `18`, получаем:

$48 = 18 × 2 + 12$

Здесь:

- $18 × 2$ — это то, сколько раз `18` поместилось в `48`,
- $12$ — это остаток

Предположим, что есть какое-то число `d`, которое делит и `48`, и `18`. 

Например, `d = 6`

Тогда  $48 = 18 × 2 + 12$ <=> $6×8=(6×3)×2+12$ <=> $6×8=(6×6)+12$

Чтобы равенство соблюдалось, $6 × 8=(6×6)+12 = (6×6) × (6 × 2)$, что верно!

### Код на С++

**Рекурсия**

```cpp
int gcd(int a, int b) {
    if (b == 0)
        return a;           
    return gcd(b, a % b);  
}
```

**Итеративный**

```cpp
#include <iostream>

int gcd(int a, int b) {
    while (b != 0) {
        int r = a % b;
        a = b;
        b = r;
    }
    return a;
}
```

**Сложность по времени:** $O(log(min(a, b))$

Почему min?

На каждом шаге `b` уменьшается:

$(a, b) → (b, a  \bmod  b)$

то есть каждый раз мы работаем с наименьшим из двух чисел

**Сложность по памяти:**

- Рекурсия: $O(log(min(a, b))$ 
  - Каждый вызов рекурсии — это **один шаг алгоритма**. Шагов алгоритма у нас $O(log(min(a, b))$. Значит, памяти у нас занимается $1 * O(log(min(a, b))$
- Итеративный: $O(1)$

## НОК (наименьшее общее кратное)

**НОК** двух чисел —это **наименьшее положительное число**, которое **делится на оба** числа без остатка.

Примеры:

Для 4 и 6:

- Кратные `4`: `4, 8, 12, 16, 20, 24…`
- Кратные `6`: `6, 12, 18, 24…`

→  $НОК=12$

Для 5 и 7:

Кратные `5`: `5, 10, 15, 20, 25, 30, 35…`

Кратные `7`: `7, 14, 21, 28, 35…`

→ $НОК=35$

**Основное свойство НОК:** $НОД(a,b)×НОК(a,b)=a×b$

И в основном именно по этой формуле и ищется нок
Ищется он как:

$\text{НОК}(a, b) = \frac{a \times b}{\text{НОД}(a, b)}$

**Код на С++**

```cpp
#include <iostream>

int gcd(int a, int b) {
    if (b == 0)
        return a;
    return gcd(b, a % b);
}

int lcm(int a, int b) {
    return (a / gcd(a, b)) * b;  // делим сначала, чтобы избежать переполнения!!
}
```

**Сложность алгоритма - такая же, как у НОД&#32;**(и по памяти и по времени)

## Простые числа

**Простое число&#32;**— это **натуральное число** больше 1, которое делится только на 1 и само на себя.

**Примеры:**

2, 3, 5, 7, 11, 13, 17, 19, 23, 29, …

- 2 — простое (делится на 1 и 2).
- 3 — простое (делится на 1 и 3).
- 4 — не простое, потому что делится на 2.
- 9 — не простое, потому что делится на 3.

2 — единственное четное простое число, все остальные простые — нечетные.

0 — не простое число!

Зачем нам нужны простые числа?

> Любое число можно разложить на произведение простых чисел,
> и это разложение — **единственное** (если не считать порядок множителей).

Эта идея — **основная теорема арифметики**.
Она лежит в основе всей теории чисел, делимости, дробей, НОД, НОК и других крутых штук

Более научная формулировка: 

> Каждое натуральное число больше 1 либо является простым, либо раскладывается в произведение простых множителей, и это разложение единственно (с точностью до порядка множителей).

## Решето Эратосфена

**Решето Эратосфена** — это **алгоритм для нахождения всех простых чисел** от 2 до N

Он работает по очень простой идее: если мы "уберем" все составные числа, то у нас останутся только простые

Запишем все числа от `2` до`N` подряд.

1. Начинаем с первого числа `(2)`— оно простое.
2. "Вычеркнем" все его кратные (`4, 6, 8, 10, …)`.
3. Переходим к следующему "невычеркнутому" числу `(3)` — оно тоже простое.
4. Убираем все кратные 3 `(6, 9, 12, 15, …).`
5. Повторяем до $\sqrt{N}$, потому что дальше кратные уже повторяются.
6. **Все, что осталось "невычеркнутым", — простые числа.**

### Почему мы идем до $\sqrt{N}$?

Допустим, у нас есть составное число `x` 

Тогда его можно записать как произведение двух чисел:

$x = a \times b$

где $a$ и $b$ — натуральные числа больше 1

Есть такой факт, что $\sqrt{x} \times \sqrt{x} = x$

Предположим, один из множетелей будет $> \sqrt{x}$

Тогда, чтобы не нарушать наш прекрасный факт, другой множитель должен быть строго $< \sqrt{x}$!

**Вывод: если число составное — один из его делителей обязательно**$≤ \sqrt{x}$**!!**

Когда мы находим все простые числа до $\sqrt{N}$ и "вычеркиваем" их кратные, **все составные числа до `N` уже будут вычеркнуты**

Потому что:

- любое составное число `N` имеет делитель $≤ \sqrt{N}$
- значит, этот делитель уже прошел по решету и "вычеркнул" все свои кратные.

```cpp
void sieve_of_eratosthenes(int n) {
    std::vector<bool> is_prime(n + 1, true);

    is_prime[0] = false;
    is_prime[1] = false;

    for (int i = 2; i * i <= n; ++i) { // i * i <= n <=> i <= sqrt(n)
        if (is_prime[i]) {
            for (int j = i * i; j <= n; j += i) { // перебираем кратные i числа
            	// идем от i * i, потому что все предыдущие кратные мы уже вычеркнули!
                is_prime[j] = false;
            }
        }
    }

    // вывод
    for (int i = 2; i <= n; ++i) {
        if (is_prime[i])
            std::cout << i << " ";
    }
    std::cout << "\n";
}
```

**Крутая гифка**

![](https://static-file-service.macro.com/file/35886d8d-c487-483e-9fa5-9a91ad01e1f3)
