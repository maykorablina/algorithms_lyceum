# Что такое граф

Граф - это структура данных, состоящая из: 
- **вершин** (nodes, vertices) - будем обозначать кол-во вершин как $V$
- **рёбер** (edges) - связей между вершинами - будем обозначать кол-во ребер как $E$

Основное предназначение графов - хранить информацию о связи объектов между собой. Например, о дорогах между городами, о "друзьях в социальных сетях" и так далее.

## Типы графов
- **По ориентрированности**
    - **Неориентированный граф**
      Рёбра без направления: A --- B (просто граф)
      
      <img src="https://github.com/user-attachments/assets/40421679-1e9f-48b8-bd8e-40bae0959f45" width="300">

    - **Ориентированный граф**
      Рёбра имеют направление: A → B
      
      <img src="https://github.com/user-attachments/assets/2fb8945f-996f-4808-9a7e-13995539d4c2" width="300">

- **По взвешенности**
    - **Невзвешенный граф**
      Просто связь без веса.

    - **Взвешенный граф**
      У каждого ребра есть вес
      
      <img src="https://github.com/user-attachments/assets/b1619d18-b99a-4b9e-b5c2-fb922a7bb57e" width="300">

- **Мультиграф**
  Несколько рёбер между двумя вершинами.
  
  <img src="https://github.com/user-attachments/assets/b31a8da6-e099-4e27-bc69-8c9cd0037221" width="300">
  
- **Граф с петлями**
  Разрешено ребро A → A
  
  *Стрелочки должны быть везде))*
  
  <img src="https://github.com/user-attachments/assets/3219b350-2291-4d55-9e22-c11f087eb2e1" width="300">
  
Все перечисленные типы могут комбинироваться между собой
Например:
    - Ненаправленный взвешенный мультиграф с петлями

    <img src="https://github.com/user-attachments/assets/cc66a7f0-6210-436b-b2db-d27e79122e63" width="300">


## Как выглядит граф в коде?

Как рисовать граф - понятно, но вот как его запрограммировать - вопрос хороший. Нет какой-то встроенной структуры данных для создания и хранения графа.

Есть **три основных способа** создания и хранения графа в коде. Каждый из них имеет свои плюсы и минусы, какой лучше использовать - зависит от задачи.

**Перед тем, как мы перейдем к способам, важное замечание:** раньше у нас сложность алгоритма зависела только от $n$ (длина массива).

Граф - это сложная структура, в нем есть две важные переменные - количество вершин и количество ребер aka $V$ и $E$. В любом алгоритме для графа мы обязательно должны учитывать и то и другое!

## 1. Список смежности (Adjacency List)

Это словарь, где ключ - это вершина, а значение - список соседей

Можно хранить ненаправленный и направленный граф, но не очень удобно для взвешенных графов

### Пример

<img src="https://github.com/user-attachments/assets/8ee802b4-a76a-4ee9-adef-f8fa04b25d47" width="300">

``` python
# питон
graph = {
    1: [2, 3],
    2: [1, 4],
    3: [1],
    4: [2]
}
```
```c++
// плюсы
#include <iostream>
#include <vector>
#include <map>

int main() {
    std::map<int, std::vector<int>> graph;

    graph[1] = {2, 3};
    graph[2] = {1, 4};
    graph[3] = {1};
    graph[4] = {2};

    return 0;
}
```

#### Плюсы

-   **Экономит память** - храним всего один словарь, сложность по памяти $O(V + E)$
-   **Удобно делать обход графа через dfs/bfs** - про это поговорим позже


#### Минусы
-   **Медленная проверка наличия ребра между двумя вершинами**
    - Чтобы понять, есть ли связь между вершинами $1$ и $2$, нужно перебрать все элементы в $graph[1]$
    - Сложность такого поиска - $O(k)$, где $k$ - количество соседей у вершины. Это не всегда оптимально!
      
## 2. Матрица смежности (Adjacency Matrix)

Матрица размера `V × V`.

`a[i][j] = 1`, если есть ребро из вершины `i` в вершину `j`, иначе `0`.

Если граф ненаправленный, то матрица будет симметрична (`a[i][j] == a[j][i]`)
Если направленный, то симметрии не будет.

Если граф взыешенный, вместо единички можно записать вес.

### Пример

Граф из 4 вершин:

|     | A | B | C | D |
|-----|---|---|---|---|
| A | 0 | 1 | 1 | 0 |
| B | 1 | 0 | 0 | 1 |
| C | 1 | 0 | 0 | 0 |
| D | 0 | 1 | 0 | 0 |

<img src="https://github.com/user-attachments/assets/89e634be-4c2f-45c8-aa2b-42669138ea75" width="300">

### Код

``` python
# питон
graph = [
    [0, 1, 1, 0],
    [1, 0, 0, 1],
    [1, 0, 0, 0],
    [0, 1, 0, 0]
]
```

``` cpp
// плюсы
#include <iostream>
#include <vector>

int main() {
    int n = 4;
    std::vector<std::vector<int>> graph = {
        {0, 1, 1, 0},
        {1, 0, 0, 1},
        {1, 0, 0, 0},
        {0, 1, 0, 0}
    };
}
```

#### Плюсы

-   **Очень быстро проверять наличие ребра** (сложность проверки $O(1)$ независимо от количества ребер и вершин)
-   **Удобно для плотных графов** (это когда много ребер) **и для некоторых алгоритмов**

#### Минусы

-   З**анимает $O(n^2)$ памяти**

## 3. Список рёбер (Edge List)

Это список из пар, где первый элемент - откуда идет ребро, второй элемент - куда приходит ребро.
Если граф направленный, порядок имеет значение!

Можно хранить и взвешенные графы, храня не пару, а список из трех элементов


``` python
# питон
edges = [
    (1, 2),
    (1, 3),
    # (2, 4, 5), если граф взвешенный
]
```

``` cpp
# плюсы
#include <iostream>
#include <vector>
#include <utility> // std::pair

int main() {
    std::vector<std::pair<int, int>> edges = {
        {1, 2},
        {1, 3},
        {2, 4}
    };
    # pair в с++ - это массив из двух элементов, к ним можно обращаться черех .first и .second
    for (const auto &e : edges) {
        std::cout << e.first << " " << e.second << "\n";
    }

    return 0;
}
```

``` cpp
#include <iostream>
#include <vector>
#include <tuple> // std::tuple
/ если граф взвешенный, то для хранения надо использовать не pair, а tuple!

int main() {
    std::vector<std::tuple<int, int, int>> edges = {
        {1, 2, 5},
        {2, 3, 7}
    };
    # tuple можно распаковать на переменные (с вектором так нельзя)
    for (const auto &e : edges) {
        int u, v, w;
        std::tie(u, v, w) = e;
        std::cout << u << " " << v << " " << w << "\n";
    }

    return 0;
}
```

#### Плюсы
- **Храним в массиве только ребра** - сложность по памяти $O(E)$
- **Удобно применять в алгоритмах на ребрах** - очень скоро рассмотрим алгоритмы Прима и Краскала, где так хранить граф будет удобно.

#### Минусы
- **Сложно искать соседей конкретной вершины**
- **Проверка наличия ребра между двумя вершинами медленная**
- **Не подходит для некоторых алгоритмов** - например, dfs/bfs

