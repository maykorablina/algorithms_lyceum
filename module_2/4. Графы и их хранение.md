# Что такое граф

Граф - это структура данных, состоящая из: 
- **вершин** (nodes, vertices) - будем обозначать кол-во вершин как $V$
- **рёбер** (edges) - связей между вершинами - будем обозначать кол-во ребер как $E$

Основное предназначение графов - хранить информацию о связи объектов между собой. Например, о дорогах между городами, о "друзьях в социальных сетях" и так далее.

## Виды графов
- **По ориентрированности**
    - **Неориентированный граф**
      Рёбра без направления: A --- B (просто граф)
      
      <img src="https://github.com/user-attachments/assets/40421679-1e9f-48b8-bd8e-40bae0959f45" width="300">

    - **Ориентированный граф**
      Рёбра имеют направление: A → B
      
      <img src="https://github.com/user-attachments/assets/40421679-1e9f-48b8-bd8e-40bae0959f45" width="300">

### Неориентированный граф

Рёбра без направления: A --- B

### Взвешенный граф

У каждого ребра есть вес: A ---5--- B

### Невзвешенный граф

Просто связь без веса.

### Мультиграф

Несколько рёбер между двумя вершинами.

### Граф с петлями

Разрешено ребро A → A


## Как хранить граф в программировании

Существует три основных способа.


## 1. Список смежности (Adjacency List)

Для каждой вершины хранятся все её соседи.

### Пример

``` python
# питон
graph = {
    1: [2, 3],
    2: [1, 4],
    3: [1],
    4: [2]
}
```
```c++
// плюсы
#include <iostream>
#include <vector>
#include <map>

int main() {
    std::map<int, std::vector<int>> graph;

    graph[1] = {2, 3};
    graph[2] = {1, 4};
    graph[3] = {1};
    graph[4] = {2};

    return 0;
}
```
#### Плюсы

-   **Экономит память** - храним всего один словарь
-   **Удобно делать обход графа через dfs/bfs**

#### Минусы

-   **Медленная проверка наличия ребра между двумя вершинами**
    - Чтобы понять, есть ли связь между вершинами $1$ и $2$, нужно перебрать все элементы в $graph[1]$
    - Сложность такого поиска - $O(k)$, где $k$ - количество соседей у вершины. 
