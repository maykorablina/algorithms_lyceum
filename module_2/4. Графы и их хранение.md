# Что такое граф

Граф - это структура данных, состоящая из: 
- **вершин** (nodes, vertices) - будем обозначать кол-во вершин как $V$
- **рёбер** (edges) - связей между вершинами - будем обозначать кол-во ребер как $E$

Основное предназначение графов - хранить информацию о связи объектов между собой. Например, о дорогах между городами, о "друзьях в социальных сетях" и так далее.

## Типы графов
- **По ориентрированности**
    - **Неориентированный граф**
      Рёбра без направления: A --- B (просто граф)
      
      <img src="https://github.com/user-attachments/assets/40421679-1e9f-48b8-bd8e-40bae0959f45" width="300">

    - **Ориентированный граф**
      Рёбра имеют направление: A → B
      
      <img src="https://github.com/user-attachments/assets/2fb8945f-996f-4808-9a7e-13995539d4c2" width="300">

- **По взвешенности**
    - **Невзвешенный граф**
      Просто связь без веса.

    - **Взвешенный граф**
      У каждого ребра есть вес
      
      <img src="https://github.com/user-attachments/assets/b1619d18-b99a-4b9e-b5c2-fb922a7bb57e" width="300">

- **Мультиграф**
  Несколько рёбер между двумя вершинами.
  
  <img src="https://github.com/user-attachments/assets/b31a8da6-e099-4e27-bc69-8c9cd0037221" width="300">
  
- **Граф с петлями**
  Разрешено ребро A → A
  
  *Стрелочки должны быть везде))*
  
  <img src="https://github.com/user-attachments/assets/3219b350-2291-4d55-9e22-c11f087eb2e1" width="300">
  
Все перечисленные типы могут комбинироваться между собой
Например:
    - Ненаправленный взвешенный мультиграф с петлями

    <img src="https://github.com/user-attachments/assets/cc66a7f0-6210-436b-b2db-d27e79122e63" width="300">


## Как выглядит граф в коде?

Как рисовать граф - понятно, но вот как его запрограммировать - вопрос хороший. Нет какой-то встроенной структуры данных для создания и хранения графа.

Есть три основных способа создания и хранения графа в коде. Каждый из них имеет свои плюсы и минусы, какой лучше использовать - зависит от задачи.

**Перед тем, как мы перейдем к способам, важное замечание:** раньше у нас сложность алгоритма зависела только от $n$ (длина массива).

Граф - это сложная структура, в нем есть две важные переменные - количество вершин и количество ребер aka $V$ и $E$. В любом алгоритме для графа мы обязательно должны учитывать и то и другое!

## 1. Список смежности (Adjacency List)

Это словарь, где ключ - это вершина, а значение - список соседей

### Пример

``` python
# питон
graph = {
    1: [2, 3],
    2: [1, 4],
    3: [1],
    4: [2]
}
```
```c++
// плюсы
#include <iostream>
#include <vector>
#include <map>

int main() {
    std::map<int, std::vector<int>> graph;

    graph[1] = {2, 3};
    graph[2] = {1, 4};
    graph[3] = {1};
    graph[4] = {2};

    return 0;
}
```
#### Плюсы

-   **Экономит память** - храним всего один словарь, сложность по памяти
-   **Удобно делать обход графа через dfs/bfs**

#### Минусы

-   **Медленная проверка наличия ребра между двумя вершинами**
    - Чтобы понять, есть ли связь между вершинами $1$ и $2$, нужно перебрать все элементы в $graph[1]$
    - Сложность такого поиска - $O(k)$, где $k$ - количество соседей у вершины. 
