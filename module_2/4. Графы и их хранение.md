# Что такое граф

Граф - это структура данных, состоящая из: 
- **вершин** (nodes, vertices) - будем обозначать кол-во вершин как $V$
- **рёбер** (edges) - связей между вершинами - будем обозначать кол-во ребер как $E$

Основное предназначение графов - хранить информацию о связи объектов между собой. Например, о дорогах между городами, о "друзьях в социальных сетях" и так далее.

## Типы графов
- **По ориентрированности**
    - **Неориентированный граф**
      Рёбра без направления: A --- B (просто граф)
      
      <img src="https://github.com/user-attachments/assets/40421679-1e9f-48b8-bd8e-40bae0959f45" width="300">

    - **Ориентированный граф**
      Рёбра имеют направление: A → B
      
      <img src="https://github.com/user-attachments/assets/2fb8945f-996f-4808-9a7e-13995539d4c2" width="300">

- **По взвешенности**
    - **Невзвешенный граф**
      Просто связь без веса.

    - **Взвешенный граф**
      У каждого ребра есть вес
      
      <img src="https://github.com/user-attachments/assets/b1619d18-b99a-4b9e-b5c2-fb922a7bb57e" width="300">

- **Мультиграф**
  Несколько рёбер между двумя вершинами.
  <img src="https://github.com/user-attachments/assets/b31a8da6-e099-4e27-bc69-8c9cd0037221" width="300">
  
- **Граф с петлями**
  Разрешено ребро A → A
  *Стрелочки должны быть везде))*
  <img src="https://github.com/user-attachments/assets/3219b350-2291-4d55-9e22-c11f087eb2e1" width="300">
  
Все перечисленные типы могут комбинироваться между собой
Например:
    - Направленный незвешенный граф
    - Ненаправленный взвешенный мультиграф с петлями


## Как хранить граф в программировании

Существует три основных способа.


## 1. Список смежности (Adjacency List)

Для каждой вершины хранятся все её соседи.

### Пример

``` python
# питон
graph = {
    1: [2, 3],
    2: [1, 4],
    3: [1],
    4: [2]
}
```
```c++
// плюсы
#include <iostream>
#include <vector>
#include <map>

int main() {
    std::map<int, std::vector<int>> graph;

    graph[1] = {2, 3};
    graph[2] = {1, 4};
    graph[3] = {1};
    graph[4] = {2};

    return 0;
}
```
#### Плюсы

-   **Экономит память** - храним всего один словарь
-   **Удобно делать обход графа через dfs/bfs**

#### Минусы

-   **Медленная проверка наличия ребра между двумя вершинами**
    - Чтобы понять, есть ли связь между вершинами $1$ и $2$, нужно перебрать все элементы в $graph[1]$
    - Сложность такого поиска - $O(k)$, где $k$ - количество соседей у вершины. 
