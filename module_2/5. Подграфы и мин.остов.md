# Построение минимального остового дерева в графе

## Отступление: что такое дерево?
**Дерево** - это связный граф без циклов
То есть это такой граф, где:

- между любой парой вершин существует ровно один путь

- нельзя пройти по ребрам и вернуться в ту же точку, не повторив ребер

- если в дереве v вершин, то в нём всегда ровно v − 1 ребер
  
<img src="https://github.com/user-attachments/assets/ab570c92-e36c-4297-b9c1-685efe97087e" width="300">

## Подграф и остовое дерево

**Подграф** - это граф внутри графа

Например:

<img src="https://github.com/user-attachments/assets/466322d9-adcb-43d7-a415-60d77e5b16f7" width="300">

Граф с вершинами **3**, **4**, **5**, **6** и ребрами **(3, 6)**, **(5, 6)**, **(4, 5)** — это подграф.

**Остовое дерево** - это подграф, который:
- содержит все вершины исходного графа
- является деревом, то есть
	- не имеет циклов
	- имеет v - 1 ребер и все остальные свойства дерева

Остовое дерево можно построить по разному, главное, чтобы соблюдались правила построения

<img width="300" src="https://github.com/user-attachments/assets/c1d2b8c4-65a8-4537-b78c-4c9f7e36733e" />
остовое дерево

<img width="300" src="https://github.com/user-attachments/assets/2ea6cd3e-ee91-48c0-a4a8-320ed45696df" />
тоже остовое дерево

## Минимальное остовое дерево

Минимальное остовое дерево (или покороче мин. остов) существует только во взвешенных графах. 

Это такое остовое дерево, у которого сумма всех ребер минимальна среди всех остовых деревьев. 

Пример: 

<img width="600" alt="image" src="https://github.com/user-attachments/assets/85218a2e-92af-4915-b17d-5983aac02590" />

Правое нижнее остовое дерево - минимальное. 

### Как найти мин. остов?

Алгоритмов, который ищут мин. остов несколько. Самые популярные - **это алгоритмы Прима и Краскала**.

Мы с вами рассмотрим только **алгоритм Прима**. Алгоритм Краскала будет в конспекте в качестве дополнения, кому интересно - можете посмотреть.

### Алгоритм Прима

Идея у него очень простая - **будем соединять вершины друг с другом, используя ребра с минимальным весом**

Для примера возьмем граф из прошлого пункта. Выберем вершину, с которой начнем строить дерево. Мы можем выбрать любую вершину - возьмем **4**

<img width="300" alt="image" src="https://github.com/user-attachments/assets/2ceb7bdd-f264-4d3d-b4da-3df95e20f21c" />

Нам нужно связать вершину **4** с какой-нибудь другой вершиной. Из вершины **4** есть ребра в вершины **2, 3, 5, 6, 7**. Смотрим на веса ребер - из них минимальный вес имеет ребро (4, 7) с весом 1. Связываем вершины 4 и 7 через это ребро

<img width="300" alt="image" src="https://github.com/user-attachments/assets/f1f5fbe2-6ee7-48bb-a14b-572fff2e7b57" />

Мы расширили наше дерево, в нем есть вершины **4 и 7.**  Нам нужно выбрать ребро с минимальным весом, которое ведет к новой вершине. Смотрим на веса ребер, выходящих из выбранных нами вершин (они помечены голубым). Это ребро **(4, 5)** c весом **2**. Выбираем его.

<img width="600" alt="image" src="https://github.com/user-attachments/assets/ddd767d1-74af-4902-97dc-f3dbb1e57689" />

Делаем то же самое до тех пор, пока не выберем все вершины графа. Если есть несколько ребер с минимальным весом - выбираем любое

<img width="600" alt="image" src="https://github.com/user-attachments/assets/c5f2c21e-7f55-4c3c-9f39-e1543c3b5c61" />

## Код!!!
```
def primMST(graph):
    v = len(graph)          # количество вершин

    parent = [-1] * v       # родитель вершины в MST
    key    = [INF] * v      # минимальный вес ребра для подключения вершины
    used   = [False] * v    # включена ли вершина в MST

    # начинаем с вершины 0
    key[0] = 0
    parent[0] = -1  # у корня MST нет родителя

    # основной цикл: v раз добавляем по одной вершине в MST
    for _ in range(v):
        # ищем вершину с минимальным key среди неиспользованных
        u = -1
        for i in range(v):
            if not used[i] and (u == -1 or key[i] < key[u]):
                u = i

        used[u] = True

        # обновляем key для соседей вершины u
        for i in range(v):
            # graph[u][i] != 0 → есть ребро
            if graph[u][i] != 0 and not used[i] and graph[u][i] < key[i]:
                key[i] = graph[u][i]
                parent[i] = u

    # вывод результата
    for i in range(1, v):
		print(f"({parent[i]}, {i}), weight: {graph[i][parent[i]]}")
```

**Ввод:**

```
graph = [
    [0, 2, 0, 6, 0],
    [2, 0, 3, 8, 5],
    [0, 3, 0, 0, 7],
    [6, 8, 0, 0, 9],
    [0, 5, 7, 9, 0]
]
primMST(graph)
```
**Вывод:**

```
(0, 1) weight: 2
(1, 2) weight: 3
(0, 3) weight: 6
(1, 4) weight: 5
```
